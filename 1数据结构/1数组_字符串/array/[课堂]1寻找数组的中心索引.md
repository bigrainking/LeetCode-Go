### 题目

```
给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

示例 1：

输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。

示例 2：
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```



### 1. 暴力解法

遍历整个数组每个元素都当做中心索引数。

sum(中心索引左边) != sum(中心索引右边)则继续循环

否则 返回中心索引

当循环停止仍然没有找到中心数则返回 -1

```go
func pivotIndex(nums []int) int {
    len_nums := len(nums)
   
    for i := 0; i<len_nums; i++{
        //循环左边之和
        left_sum := 0
        for l := 0; l < i; l++{
            left_sum += nums[l]
        }
       //循环计算右边之和
        right_sum := 0
        for r := i+1; r < len_nums ; r++{
            right_sum += nums[r]
        }
       //比较左右是否相等
        if left_sum != right_sum {
            continue
        }else{
            return i //返回中心下标
        }
    }
    return -1
}
```



### 2. 官方解法

**改进**：

1. 只计算左边之和，循环之前就把整体的和计算出来就可以O(1)计算右边的和

2. 整体之和在遍历数组外面计算完成则从原来的O(n*n)变为O(n)



#### 2.1 方法一：(我看了之后)

**Tips**:

计算左边之和不需要再用一个for循环，直接在一边遍历假设中位数一边计算左边总和。

（但这样计算出的结果包含了中位数本身，因此在后面比较左右是否相等中要减去中位数

```go
func pivotIndex(nums []int) int {
    // 计算总和
    total := 0
    for _, val := range nums {
        total += val
    }

    
    sum := 0
    for k, val := range nums {
    // 计算左边之和 + 中位数
    sum += val
       
    // 左边之和*2 + 中位数 = total则中位数成立
    if (sum-val)*2 + val == total {
        return k
    }else {
        continue
    }
    }
    // 没有中位数
    return -1
}
```



#### 2.2 标准答案：

在计算左边之和过程中**不需要**每次减去中位数。

采用先判断当前数是否为中位数，如不是则再把它放到左边。（哈哈哈， 和刚才我没管是他不是中位数就直接加进去的方法相比）

```go
//其余部分一样
....
for k, val := range nums {
   // 先判断再加和
   if sum*2 + val == total {
      return k
   }
   sum += val //该假设中位数不成立，则放到左边之和中继续向右扫描
}
return -1
```







