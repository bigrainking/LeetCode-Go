[题目]()



```
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
给你一个元素值互不相同的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素 
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

示例 1：
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

示例 2：
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

示例 3：
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```



## 题解：

分析：

一共分为下面两种情况：

① 进行了旋转

<img src="pic/%5Bclass%5D%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E5%80%BC.assets/image-20220315112442121.png" alt="image-20220315112442121" style="zoom: 50%;" />



②没有进行旋转 

<img src="pic/%5Bclass%5D%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E5%80%BC.assets/image-20220319191631531.png" alt="image-20220319191631531" style="zoom:33%;" />															



1. 对于第二种单调递增情况非常简单，直接缩减区间找到最小值

   - nums[mid] < nums[right]则向左 min值在[left, mid]， 直接不断缩减区间，直到left == right 即找到最小值

2. 对于第一种情况：

   - 无论何时，以最大值为界，左边区域所有元素全部大于右边。因此无论mid在任何位置可以有

      - nums[mid] > nums[right] 去掉左区域 min值在 [mid + 1, right]
      - nums[mid] < nums[right] 去掉右区域 min值在[left, mid] // 因为有可能此时的mid时最小值

      - 区间不断缩减，直到left == right时跳出循环剩下的最后一元素 nums[left]就是我们的最小值

3. 上面两种情况的缩减区域方式是一样的，因此不用分情况写

   ```go
   func findMin(nums []int) int {
       lens := len(nums)
       left, right := 0, lens-1
       for left < right { //需要mid与右边的邻居比较才能判断mid是否满足条件，使用模板2
           mid := left + (right - left)/2
           if nums[mid] < nums[right] { //右边有序，则mid已经是右边min,向左下坡
               right = mid
           }else { //向右下坡
               left = mid + 1
           }
       }
       return nums[left] // 此时left与right重合
   }
   ```

   