[toc]



<img src="pic/%5Bz%5D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/image-20220620103709317.png" alt="image-20220620103709317" style="zoom:33%;" />



# 常数时间的操作

<img src="pic/%5Bz%5D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/image-20220620111015176.png" alt="image-20220620111015176" style="zoom:25%;" />

位运算：无论数字大小都是操作32位，因此数字带符号不带符号右移都是常数时间操作

时间不固定：比如对于链表Get(i) 时间不固定，对于数组Get(i)时间固定永远是1



# 计算复杂度的流程

> 用最差情况来计算时间复杂度

<img src="pic/%5Bz%5D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/image-20220620111845301.png" alt="image-20220620111845301" style="zoom:25%;" />

将整个运算过程拆分到常数级别的操作，一定要拆分到最彻底。

比如：选择排序，每一步是选择 x ~ N的最小值，一共有N步；

拆分时，选择 x ~ N的最小值如果拆到这步就不够，这步不是常数时间的操作，是 N

# 确定时间复杂度

最后：

当N大到一定程度，高阶项的系数和低阶项都不会产生影响了（太小了）

<img src="pic/%5Bz%5D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/image-20220620111914952.png" alt="image-20220620111914952" style="zoom:33%;" />

<img src="pic/%5Bz%5D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/image-20220620112426001.png" alt="image-20220620112426001" style="zoom:25%;" />





---

# 举例

冒泡排序、插入排序、选择排序







# 空间复杂度

> 作为输出结果，输入参数的空间不算额外空间

<img src="pic/%5Bz%5D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/image-20220620115156117.png" alt="image-20220620115156117" style="zoom:25%;" />

`function([k]int) []int {}`

如果要求返回一个数组，然后我们申请了一个result数组用来承载需要返回的数组：O(1)

因为是function要求的，而不是我们自己要使用的额外的空间



## 时间复杂度一样：拼常数项

> 用实际运行的时间去比较

<img src="pic/%5Bz%5D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/image-20220620115527005.png" alt="image-20220620115527005" style="zoom:25%;" />



# 时间复杂度：logN 

看到logN默认以2为底， 不是以2为底，以K为底，那么就要写底数logkN





# 补充

[左神第一节](https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=2&vd_source=47272764e1eb400edc65776bfe6a48af)

`>>`带符号位右移 ：所有数字右移，右移之后首位空出来了，首位就用原来的符号位来填充

`>>>`不带符号位右移：~~~~首位用0填充

举例

1000 1100 //其中第一个1是符号位，表示 `-`

`>>` 带符号位右移结果 `1 1000 110` 每个数字都往右移动一格，首位空出来来用原来的符号位1相同数字填充

`>>>` 不带符号位右移结果 `0 1000 110` 每个数字都往右移动一格，首位无论符号位之前是什么都用0填充