

[toc]

# 一、方法

### 1. 过程

题目 从暴力递归 到 动态规划的过程

1 找到暴力递归的尝试写法： **尝试**

2 记忆化搜索：Map直接记录每一步的结果，后续遇到相同的直接调用

3 经典动态规划： 精细化组织，**建立出N维表**

4 经典动态规划优化： 填写N维表的优化

- 对于**无枚举行为**的记忆化搜索，不需要改进为经典动态规划

   **枚举行为**：只依赖于有限个格子， 比如前面一节`如何改经典动态规划`中的三个例题就是依赖于有限个格子（这些有限个格子不存在for循环情况，存在则说明是无限多(非常多)个子状态）

<img src="../../%25E5%25B7%25A6%25E7%25A8%258B%25E4%25BA%2591%25E8%25AF%25BE%25E7%25A8%258B/%25E4%25B8%2589%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592/%25E4%25B8%2589%25E6%259A%25B4%25E5%258A%259B%25E6%2594%25B9%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592/pic/%25E5%25A6%2582%25E4%25BD%2595%25E5%2586%2599%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592.assets/image-20220727225538453.png" alt="image-20220727225538453" style="zoom:25%;" />

### 2. 复杂度

比如背包问题，决策是否选择当前背包，使用二叉树， 

暴力递归复杂度为  O(2^n)

经典动态规划使用一张 bag * N 的表格， 复杂度O(bag * N )

>  PS： **记忆化搜索**
>
>  记忆化搜索就是没有结构的记录，调用过程中的结果。 比如只用一个数组来记录调用过程中的每个结果值， 相比经典动态规划会用一张相应的表，表中的格子还会有依赖关系，而记忆化搜索不存在这样的结构表





# 二、步骤

改动态规划只需要暴力尝试的代码，不需要知道题意



1. 查看变量个数，几个决定递归函数的变量就是，N维表格

2. 用base case来填写部分表格：部分值可以直接填入

   ```go
   if index == len(w) { return 0
   ```

3. 找到格子之间的依赖关系，按照依赖关系来填写表格

   ```go
   p1 := float64(arr[L]) + S(arr, L+1, R)
   p2 := float64(arr[R]) + S(arr, L, R-1)
   ```

   

