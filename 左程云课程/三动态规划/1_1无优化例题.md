# 三、例题(无优化的动态规划)



## 1. 二维表

- [背包问题](..\一暴力递归几个模型\2从左往右尝试_背包问题.md)

源代码

```go
// rest背包此时剩余的空间
func process22(w, v []int, index, rest int) (value int) {
	// base case1:没有剩余空间
	if rest < 0 {
		return -1
	}
	// base case2:还有剩余空间，在index已经遍历完了之后
	if index == len(w) {
		return 0
	}

	// 列举所有可能性
	// 不选择当前背包
	p1 := process22(w, v, index+1, rest) //剩余空间不变
	// 选择当前背包
	p2 := -1                                          //假设背包重量是p2
	p2next := process22(w, v, index+1, rest-w[index]) //剩余空间--
	if p2next != -1 {
		p2 = v[index] + p2next //剩余空间 + 后面背包的value
	}
	return int(math.Max(float64(p1), float64(p2)))
}
```



1. 根据上面暴力代码中：index = N 时，return 0， 因此可以填好最后一行。

<img src="../%E4%B8%80%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B/pic/2%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E5%B0%9D%E8%AF%95_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.assets/image-20220727174139933.png" alt="image-20220727174139933" style="zoom: 25%;" />

2. 从倒数第二行开始填写

 为什么要从N+1行开始填写呢？  （列从左or从右无所谓）

- 因为最先得到的值是 index = N+1 位置的值，后面所有要填写的格子都依赖于这些已经填好的格子



**实现**

```go
func proCache(w, v []int, bag int) int {
	// 1. 创建二维表并初始化
	// 最后一行填入0
	dp := make([][]int, len(w)+1)
	for index := range dp {
		dp[index] = make([]int, bag+1)
	}

	// 2. 循环填写二维表:从N+1行开始填写
	for index := len(w) - 1; index >= 0; index-- {
		for rest := 0; rest <= bag; rest++ {
			// 用暴力递归的代码来改进
			// p1 := process22(w, v, index+1, rest) //剩余空间不变
			p1 := dp[index+1][rest]
			// p2 := -1                                          //假设背包重量是p2
			// p2next := process22(w, v, index+1, rest-w[index]) //剩余空间--
			// if p2next != -1 {
			// 	p2 = v[index] + p2next //剩余空间 + 后面背包的value
			// }
			p2 := -1
			if rest-w[index] > 0 {
				p2 = v[index] + dp[index+1][rest-w[index]]
			}
			// return int(math.Max(float64(p1), float64(p2)))
			dp[index][rest] = int(math.Max(float64(p1), float64(p2)))
		}
	}
	return dp[0][bag]
}
```



## 2. 一维表

- [数字转换符号](..\一暴力递归几个模型\2从左往右尝试_数字转字符号.md)

```go
func process21(str string, index int) int { //index表示当前位置
	// base key结束条件：字符串已经没有数字再分块
	// 	将当前分块好的字符串对应成字母，加入res
	// // 什么情况下str能完全地转换成字母，并加入res
// 1.当前index到达最后一位 :
if index == len(str) {
	// 	说明整个str所有number都完成了兑换，这是一种result。result+1
	// 	return 1
	return 1
}
// 2.没有到达最后一步，提前终止：当前str[index]=='0' 0没有可以兑换的字母，这条路直接pass，分支限界： 比如10 A0，0没有对应的字母
if str[index] == '0' {
	// 	这条路return0
	// 	return 0
	return 0
}

// 2. 当前位置是1~2：
// 	str[index]==1:
// 		单独将index位置翻译: 继续深度递归：直接进入process(index+1)
// 		如果index+1还没有到达str末尾：将index+1和自己一起翻译； 同时直接进入 process(index+2)
if str[index] == '1' {
	res := process21(str, index+1)
	if index+1 < len(str) {
		res += process21(str, index+2) //将两种情况相加 == 2
	}
	return res
}
// 	str[index]==2:
// 		将自己位置单独翻译；
// 		如果index+1没有达到str末尾&&str[index+1]在0~6之间：一起翻译；同时进入process(index+2)
if str[index] == '2' {
	res := process21(str, index+1)
	if index+1 < len(str) && str[index+1] <= '6' {
		res += process21(str, index+2)
	}
	return res
}
if '3' <= str[index] && str[index] <= '9' {
	return process21(str, index+1)
}
// // 接下来列出当前位置的可能性
// 分为2种情况：当前位置是1、2； 3~6

// 1. 当前位置是3~6 ：
// 	只能将index位单独兑换字母，而不能将融合两个字母
return 0
}
```



**实现**


```go
func dpway(str string) int {
	// 创建一维表
	dp := make([]int, len(str)+1)
	dp[len(str)] = 1 //base case

	// 填写表
	for index := len(str) - 1; index >= 0; index-- {
		if str[index] == '1' {
			dp[index] = dp[index+1]
			if index+1 < len(str) {
				dp[index] += dp[index+2]
			}
		}
		if str[index] == '2' {
			dp[index] = dp[index+1]
			if index+1 < len(str) && str[index] <= '6' {
				dp[index] += dp[index+2]
			}
		}
		if '3' <= str[index] && str[index] <= '9' {
			dp[index] = dp[index+1]
			return process11(str, index+1)
		}
	}
	return dp[0]
}
```

## 3. 两张表

- 两个人拿牌

1. L....R 是一个范围，如L > R 范围无效

2. 创建两张表 ： F S

3. 对角线上的值是确定的

4. 找到依赖关系：从下面的代码中可以推出依赖关系

   ```go
   p1 := float64(arr[L]) + S(arr, L+1, R)
   p2 := float64(arr[R]) + S(arr, L, R-1)
   ```

   星星依赖 他左边 & 他下面 格子对应在S表中 的值

   因此**我们需要按斜线填写格子中的值**

   

   <img src="../%E4%B8%80%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B/pic/3%E8%8C%83%E5%9B%B4%E4%B8%8A%E7%9A%84%E5%B0%9D%E8%AF%95%E4%B8%A4%E4%BA%BA%E6%8B%BF%E7%BA%B8%E7%89%8C.assets/image-20220727221140350.png" alt="image-20220727221140350" style="zoom: 25%;" />

   PS 填对角线的方法

   <img src="pic/1%E5%A6%82%E4%BD%95%E6%94%B9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220727222859541.png" alt="image-20220727222859541" style="zoom:25%;" />

   ```go
   // 每条斜线 i=0 1 2 3 如上(i=0的对角线已经填好)
   	for i := 1; i < lenarr; i++ {
         // 每条斜线第一个元素格子(你看表格第一行，每条斜线的第一个格子)
   		L, R := 0, i
   		for L < lenarr && R < lenarr {
   			....
            //L R一起沿着斜线右下移动
   			L++
   			R++
   		}
   	}
   ```


```go
func ProCache(arr []int) int {
	lenarr := len(arr)
	// 创建两张表,填写两个对角线
	dpF, dpS := make([][]int, lenarr), make([][]int, lenarr)
	for i := range dpF {
		dpF[i], dpS[i] = make([]int, lenarr), make([]int, lenarr)
		dpF[i][i] = arr[i] //if L == R { return float64(arr[L])
		dpS[i][i] = 0
	}

	// 填对角线
	for i := 1; i < lenarr; i++ {
		// 斜线第一个元素格子
		L, R := 0, i
		for L < lenarr && R < lenarr {
			// 更新F表
			f1, f2 := arr[L]+dpS[L+1][R], arr[R]+dpS[L][R-1]
			dpF[L][R] = int(math.Max(float64(f1), float64(f2)))
			// 更新S表
			s1, s2 := dpF[L+1][R], dpF[L][R-1]
			dpS[L][R] = int(math.Min(float64(s1), float64(s2)))
			L++
			R++
		}

	}
	return int(math.Max(float64(dpF[0][lenarr-1]), float64(dpS[0][lenarr-1])))
}
```



