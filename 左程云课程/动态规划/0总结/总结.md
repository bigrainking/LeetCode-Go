

[toc]

<img src="pic/%E6%80%BB%E7%BB%93.assets/image-20220814185327692.png" alt="image-20220814185327692" style="zoom:33%;" />

# 一、暴力递归

## 1 暴力递归的尝试模型

1. 什么是暴力递归：

   直接按照人脑尝试每一种结果列出来，暴力递归写出来。 比如一个字符串有多少个子串？一一列出来

   **例题**

   汉诺塔

   栈的逆序

   

2. 如何尝试每一种结果：

   用下面的四种模型

### 1 从左往右的尝试模型

1. 模型：

   给定一个类似数组的对象，从左往右一一取出一部分，凑成我们想要的结果。比如字符串但规定只能从左往右拿

2. 尝试方法：

   从左往右列出所有结果的可能性



**例题**

1. 字符串的子串、子序列相关问题：

   字符串全排列

   字符串子串

   字符串子序列

### 2 范围上的尝试模型

给定一个范围，不用可以从左右两边出发

**例题**

1. 两个人从**左右两边**开始拿牌，博弈
2. 机器人**在一条直线上**的任意位置想要走到目标位置：机器人可以**左右任意移动** 

上面两个例题都是在一个范围上(一条坐标轴、一副牌)尝试(从左从右开始都可以)

### 3 多样本位置全对应模型

上面两种模型的尝试都只有一个样本，这个样本就是他们的范围。 多样本的范围就是所有样本的合集。

**例题**

1. 找两个字符串的最长公共子序列：

   将两个字符串分别对应横纵坐标(样本全对应)，

   建立二维表， 每个格子的值表示两个字符串的最长公共子序列的长度

### 4 寻找业务限制模型

上面三种模型的暴力递归改动态规划不需要知道原题意，只需要源代码。

而本模型 关于**确定DP维度表的横纵坐标范围需要从原题意中获得**（从原题意中寻找业务限制）

**例题**

1. 从咖啡机and挥发中组合出，洗多个咖啡杯的最优方法


# 二、暴力递归改动态规划

## 1 什么样的暴力递归可以改动态规划？

1. 过程中有重复调用子问题：比如斐波那契数列F(5) = F(4)+F(3) 其中F(3)之前已经计算过，直接调用之前计算了的结果即可，不用每次都重复计算F(3)

   对于没有重复调用子问题的暴力递归不能改成动态规划

## 2 步骤

### 2.1 记忆化搜索

1. 暴力递归中每每调用一次就记录下来，后面每次需要调用时先看之前否有有计算过，如果计算过则直接调用之前的结果。

2. 记录存储的方式直接用HashMap(数组也可以)：key = 调用的参数， value = 调用后返回的结果

### 2.2 经典动态规划

记忆化搜索还是需要递归调用，但是优化后的暴力递归。 动态规划不需要递归调用。

#### 从暴力递归到动态规划：

1. 根据尝试模型，写出暴力递归
2. 【确定N维表】根据函数的参数个数(是每次递归调用都会变化的参数)，以及每个参数的变化范围(根据原来暴力递归来确定变化范围)确定N维表
3. 【确定直接可以填写的格子】从原来暴力递归中的base case一般可以填写部分表格
4. 【确定格子之间的依赖关系，填写格子】用暴力递归中的递归调用的代码，找到依赖关系(每个格子和其他格子之间的关系)，再根据已经填写部分，逐步填写完所有格子
5. 返回需要的那一格

### 2.3 动态规划的优化

优化是对经典动态规划填写格子方法的优化



**1）上面的依赖关系中会出现两种情况**：

1. 仅依赖少量的格子：N-1行某个格子需要依赖自己前面and下面一个格子才能得出值
2. 依赖大量格子：N-1行的某个格子需要：下面一整行的格子and本行自己前面所有各自



**2）那种情况需要动态规划优化？**

第二种情况。

第一种情况不需要优化



**3）如何优化？**

比如上面情况中第二种情况，可以直接 = 上一个格子+额外其他的格子。

<img src="pic/%E6%80%BB%E7%BB%93.assets/image-20220814181144966.png" alt="image-20220814181144966" style="zoom: 25%;" />



## 3 评估暴力方法的好坏

同一个模型有不同的尝试方法，评估的方法是看 **可变参数的个数**



可变参数个数决定了动态规划是？维表

## 4 暴力递归设计原则

1. 原则1: 每个可变参数的类型一定 **不能比Int复杂**

   > Int的变化范围可以直接确定，
   >
   > 数组、字符串等的变化范围无穷多，无法一一列举，就无法构建有界限的N维表
   >
   > 比如：[]int {1} {1,2} {23312} 多无穷多种情况
   >
   > <img src="pic/%E6%80%BB%E7%BB%93.assets/image-20220814183315873.png" alt="image-20220814183315873" style="zoom:25%;" />

2. 原则2： 如果参数比Int复杂是 **一维先行结构**，那么只能有一个可变参数

   无法列出N维表， 可以用 **记忆化搜索解决**

3. 原则3： 可变参数能少则少