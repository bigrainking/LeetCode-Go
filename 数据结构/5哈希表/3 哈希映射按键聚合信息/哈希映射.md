

[toc]



[教程地址](https://leetcode.cn/leetbook/read/hash-table/xhy35e/)

# 一、哈希映射

哈希映射相比哈希集合存储的（key,value）键值对



# 二、哈希映射用法

```python
# 1. initialize a hash map
hashmap = {0 : 0, 2 : 3}
# 2. insert a new (key, value) pair or update the value of existed key
hashmap[1] = 1
hashmap[1] = 2
# 3. get the value of a key
print("The value of key 1 is: " + str(hashmap[1]))
# 4. delete a key
del hashmap[2]
# 5. check if a key is in the hash map
if 2 not in hashmap:
    print("Key 2 is not in the hash map.")
# 6. both key and value can have different type in a hash map
hashmap["pi"] = 3.1415
# 7. get the size of the hash map
print("The size of hash map is: " + str(len(hashmap)))
# 8. iterate the hash map
for key in hashmap:
    print("(" + str(key) + "," + str(hashmap[key]) + ")", end=" ")
print("are in the hash map.")
# 9. get all keys in hash map
print(hashmap.keys())
# 10. clear the hash map
hashmap.clear();
print("The size of hash map is: " + str(len(hashmap)))
```



# 三、例题:两数之和

[题目：easy](https://leetcode.cn/leetbook/read/hash-table/xhb0fv/)

我：数组中出现两个相同数字的情况没有成功解决,看了官方题解 6.07



<img src="pic/%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84.assets/image-20220607121541340.png" alt="image-20220607121541340" style="zoom: 33%;" /> <img src="pic/%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84.assets/image-20220607121558554.png" alt="image-20220607121558554" style="zoom:33%;" />





### 解析

1. **使用哈希映射存储整个nums数组来减少查找另一个数字的时间**，

   哈希表中存储{num：index},每个元素值对应的在nums中的index

   在哈希表中查看是否有taget - currentnum



**实现中的解析**

2. **解决出现current == target - current时，hash找到的是相同数字相同索引的情况。**

  解决nums中有两个一样的数字的方法

  迭代数组，每次存入hash时候查看 hash[target - current]是否存在

  如果存在，则找到，并返回当前数字的index 和 hash中数字的index

  避免了一种情况，数组中有两个相同的元素，target - current == current , 这种情况两个num无法存入hash中。

  通过每次存储都查看hash[taget - current],当出现上述情况时，返回的是hash对应的index和 自己的index

  比如[3, 3]

  hash index == 0

  current index == 1

​	

**复杂度分析**

  时间复杂度：迭代数组 O(n)， 找是否有符合条件的另一个数字O(1)

  空间复杂度：O(n)

### 实现

```go
func twoSum(nums []int, target int) []int {
    hashTable := map[int]int{}
    for index, num := range nums {
        if val, ok := hashTable[target - num]; ok {
            return []int{val, index}
        }
        hashTable[num] = index
    }
    return nil
}
```











